好, 基于这些假设, 我们来看看如何实现***
那么能不能做到***呢?
那么, 万一真正的发生了冲突呢? 
那么, 当内存写满了呢? 再看上面的内存分配图, 注意到红色的部分没有?
那么万一原有的内存不够呢? 那就分配呗.
那么, 万一Key Slots不够了呢?
要搞明白这个原因, 首先我们要知道浮点数的表示
这里的关键点就在于
可见, 这个问题的关键点就是: “你看似有穷的小数, 在计算机的二进制表示里却是无穷的”
废话不多说, 直接看代码:
究其原因, 也就是bindParam和bindValue的不同之处,
让我们把上面的代码的foreach拆开, 也就是这个foreach:相当于:
最后, 展开了说, 对于要求参数是引用, 并且有滞后处理的函数, 都要在使用foreach的时候, 谨慎!
经过了解, 一个简单的可重现的脚本如下:
考虑到这个问题可能具有一定的普遍性, 
这里的问题就在于/dev/random
后记, 大家看手册, 一定也要看手册下面的评论, 呵呵, 有很多东西在评论中, 是有提到的, 
考虑如下的场景:
那么, 能不能对这个系统做解耦呢?
这里还有一个细节
诚然, 这个理由是对的, 不过, 我今天要说的, 是另外一个的原因.
我们知道, ****意思是说, 比如:
也就
你使用include_once, 只能证明, 你对自己的代码没信心.
所以, 我们一定要让连接代价最高的资源, 最先初始化.
这个问题乍看, 确实很容易让人迷惑, 但实际上, 造成这样的误解的根本原因在于: 在PHP中, 判断静态与否不是靠”::”(PAAMAYIM_NEKUDOTAYIM)符号, 而是靠calling scope.
那么, 什么是calling scope?
那么PHP为什么要这么设计呢? 考虑下面的例子:
到这里, 请大家注意这句:”它的编译不做任何语义优化”….
可见, PHP的程序员, 需要认真的想好, 你的代码会怎么被执行, 你怎么写代码, 最终的执行效率才最高. 而不像其他的语言, 程序员可以把一部分优化工作交给编译器.
注意到, 如果此时***, 并且此时这个变量刚好是第max_input_vars个变量的时候, 会触发一个警告(1), 此时一切正常.
但是, 如果此时还是注册一个数组变量, 但是这个变量已经是第max_input_vars + 1个变量的时候, 那么此时gpc_element_p将成为一个未初始化的指针, 而因为现在逻辑会继续走, 也就会走到(2)号位置, 导致解引用了一个未初始化的指针. 于是, Boomb~
起作用的时刻

会发生什么事情呢?  让我来一步一步描述下
现在让我们看看关键的数据结构

最近在做一个需要用到异步PHP的项目， 翻阅PHP源码的时候，发现了三个没有用过的模块，sysvsem,sysvshm,sysvmsg,一番研究以后，受益非浅。

虽然知道解决方法，也知道是Apache的原因，但是一直没有去找其所以然，今天趁机，就研究了一下。

编写的时候，遇到的第一个问题就是，moudule申明，不能通过编译，编译器提示重复定义。查了N遍手边的apache源码分析，也没有找到原因,如：
最后，删除掉第一个module申明， 通过编译。
这俩个问题这么糊涂的解决以后，接下来的工作就很简单了。
ps: 看源代码，是最快的学习方法。







